<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Happy Diwali â€” 3D Crackers</title>
<style>
  html,body { height:100%; margin:0; background: radial-gradient(ellipse at center, #050517 0%, #000 60%); overflow:hidden; font-family: sans-serif; color: #fff }
  #overlay { position: absolute; left: 0; right:0; top:0; pointer-events:none; text-align:center; padding-top:20px; z-index:10 }
  #overlay .card { display:inline-block; background: rgba(255,255,255,0.06); padding:12px 18px; border-radius:10px; pointer-events:auto; }
  #hint { position:absolute; bottom:18px; left:0; right:0; text-align:center; font-size:14px; color:#ccc; z-index:10 }
  a.btn { color:#111; background: #ffd54a; padding:8px 12px; border-radius:8px; text-decoration:none; font-weight:700; }
</style>
</head>
<body>
<div id="overlay">
  <div class="card">
    <strong>Happy Diwali âœ¨</strong> â€” Tap / Click anywhere for 3D crackers!
    &nbsp;<a class="btn" href="#" id="launchBtn">Launch ðŸŽ†</a>
  </div>
</div>
<div id="hint">Tip: Open in full-screen (browser) for best experience.</div>

<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
<script>
/*
  Simple fireworks using Three.js Points and small particle physics.
  - Click/tap or press Launch to create bursts.
  - Works on mobile and desktop browsers.
*/

let scene, camera, renderer, clock;
let particles = [];
const GRAVITY = new THREE.Vector3(0, -0.018, 0);
const PARTICLE_LIFE = 120; // frames
const MAX_PARTICLES = 5000;

init();
animate();

function init(){
  clock = new THREE.Clock();
  scene = new THREE.Scene();

  const width = window.innerWidth;
  const height = window.innerHeight;
  camera = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000);
  camera.position.set(0, 15, 40);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(width, height);
  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
  document.body.appendChild(renderer.domElement);

  // add subtle ambient glow
  const hemi = new THREE.HemisphereLight(0xaaaaee, 0x080820, 0.6);
  scene.add(hemi);

  // create a buffer to reuse for particle geometry
  particleGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(MAX_PARTICLES*3);
  const colors = new Float32Array(MAX_PARTICLES*3);
  const alphas = new Float32Array(MAX_PARTICLES);
  const sizes = new Float32Array(MAX_PARTICLES);

  particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  particleGeometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
  particleGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
  particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

  // simple shader material for point sprites with alpha
  const material = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    uniforms: {
      pointTexture: { value: null }
    },
    vertexShader: `
      attribute float alpha;
      attribute float size;
      attribute vec3 customColor;
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        vAlpha = alpha;
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        // circular soft point
        float dist = length(gl_PointCoord - vec2(0.5));
        float mask = smoothstep(0.5, 0.48, dist);
        gl_FragColor = vec4(vColor, vAlpha * mask);
      }
    `
  });

  particleSystem = new THREE.Points(particleGeometry, material);
  scene.add(particleSystem);

  // fill arrays with zeros
  resetAttributes();

  window.addEventListener('resize', onWindowResize);
  renderer.domElement.addEventListener('pointerdown', e => {
    createFirework(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
  });

  document.getElementById('launchBtn').addEventListener('click', (e) => {
    e.preventDefault();
    createFirework(Math.random(), 0.25 + Math.random()*0.5);
  });

  // auto-launch a few on start
  setTimeout(()=>{ for(let i=0;i<3;i++) setTimeout(()=>createFirework(Math.random(), 0.2+Math.random()*0.6), i*400) }, 600);
}

function resetAttributes(){
  const pos = particleGeometry.attributes.position.array;
  const col = particleGeometry.attributes.customColor.array;
  const alpha = particleGeometry.attributes.alpha.array;
  const size = particleGeometry.attributes.size.array;
  for(let i=0;i<MAX_PARTICLES;i++){
    pos[i*3]=pos[i*3+1]=pos[i*3+2]=9999; // offscreen
    col[i*3]=col[i*3+1]=col[i*3+2]=0;
    alpha[i]=0.0;
    size[i]=1;
    particleState[i] = null;
  }
  particleGeometry.attributes.position.needsUpdate = true;
  particleGeometry.attributes.customColor.needsUpdate = true;
  particleGeometry.attributes.alpha.needsUpdate = true;
  particleGeometry.attributes.size.needsUpdate = true;
}

// track state per-index
let particleState = Array(MAX_PARTICLES).fill(null);

function createFirework(normX, normY){
  // convert normalized coords to world coords near horizon
  const x = (normX - 0.5) * (window.innerWidth / window.innerHeight) * 28;
  const y = (1 - normY) * 18 + 2;
  const z = (Math.random()-0.5) * 10;

  // create a launch rocket that travels up then explodes
  launchRocket(new THREE.Vector3(x, 0, z), new THREE.Vector3(0, 0.5 + Math.random()*0.7, 0), y, getRandomPalette());
}

function getRandomPalette(){
  const palettes = [
    [0xffdc00, 0xff6b6b, 0xffb86b, 0x00d2ff],
    [0xff4dff, 0x7c4dff, 0x43e97b, 0xffde59],
    [0xff6bcb, 0xffd56b, 0x8ad4ff, 0xa0ffd6],
    [0xffffff, 0xff9f1c, 0xff1654, 0x0abf5b]
  ];
  return palettes[Math.floor(Math.random()*palettes.length)];
}

function launchRocket(startPos, velocity, explodeHeight, palette){
  const rocket = {
    type: 'rocket',
    pos: startPos.clone(),
    vel: velocity.clone(),
    age: 0,
    explodeHeight,
    palette
  };
  particles.push(rocket);
}

function explode(p){
  const count = 60 + Math.floor(Math.random()*80);
  const speed = 0.8 + Math.random()*2.2;
  for(let i=0;i<count;i++){
    // find free index
    let idx = findFreeParticleIndex();
    if(idx < 0) break;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos((Math.random()*2)-1);
    const dir = new THREE.Vector3(
      Math.sin(phi)*Math.cos(theta),
      Math.cos(phi),
      Math.sin(phi)*Math.sin(theta)
    );
    const sp = speed * (0.4 + Math.random()*1.6);
    particleState[idx] = {
      pos: p.pos.clone(),
      vel: dir.multiplyScalar(sp),
      age: 0,
      life: PARTICLE_LIFE,
      colorHex: p.palette[Math.floor(Math.random()*p.palette.length)],
      size: 3 + Math.random()*6
    };
    // write initial attributes
    const positions = particleGeometry.attributes.position.array;
    const colors = particleGeometry.attributes.customColor.array;
    const alphas = particleGeometry.attributes.alpha.array;
    const sizes = particleGeometry.attributes.size.array;

    positions[idx*3] = particleState[idx].pos.x;
    positions[idx*3+1] = particleState[idx].pos.y;
    positions[idx*3+2] = particleState[idx].pos.z;

    const c = hexToRgb(particleState[idx].colorHex);
    colors[idx*3] = c.r/255;
    colors[idx*3+1] = c.g/255;
    colors[idx*3+2] = c.b/255;

    alphas[idx] = 1.0;
    sizes[idx] = particleState[idx].size;

    particleGeometry.attributes.position.needsUpdate = true;
    particleGeometry.attributes.customColor.needsUpdate = true;
    particleGeometry.attributes.alpha.needsUpdate = true;
    particleGeometry.attributes.size.needsUpdate = true;
  }
}

function findFreeParticleIndex(){
  for(let i=0;i<MAX_PARTICLES;i++){
    if(particleState[i] === null) return i;
  }
  return -1;
}

function hexToRgb(hex){
  const r = (hex >> 16) & 255;
  const g = (hex >> 8) & 255;
  const b = hex & 255;
  return {r,g,b};
}

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // update rockets/emitters
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    if(p.type === 'rocket'){
      p.age++;
      // simple physics
      p.pos.add(p.vel.clone().multiplyScalar(1.0));
      p.vel.add(GRAVITY.clone().multiplyScalar(0.5));
      // draw a small spark trail
      let idx = findFreeParticleIndex();
      if(idx>=0){
        particleState[idx] = {
          pos: p.pos.clone(),
          vel: new THREE.Vector3((Math.random()-0.5)*0.05, -0.02 + (Math.random()-0.02), (Math.random()-0.5)*0.05),
          age:0,
          life: 30,
          colorHex: 0xfff1b2,
          size: 2 + Math.random()*2
        };
        const positions = particleGeometry.attributes.position.array;
        const colors = particleGeometry.attributes.customColor.array;
        const alphas = particleGeometry.attributes.alpha.array;
        const sizes = particleGeometry.attributes.size.array;
        positions[idx*3] = particleState[idx].pos.x;
        positions[idx*3+1] = particleState[idx].pos.y;
        positions[idx*3+2] = particleState[idx].pos.z;
        const c = hexToRgb(particleState[idx].colorHex);
        colors[idx*3] = c.r/255; colors[idx*3+1]=c.g/255; colors[idx*3+2]=c.b/255;
        alphas[idx]=0.9; sizes[idx]=particleState[idx].size;
      }

      // explode condition
      if(p.pos.y >= p.explodeHeight || p.age>180){
        explode(p);
        particles.splice(i,1);
      }
    }
  }

  // update particle states
  const positions = particleGeometry.attributes.position.array;
  const colors = particleGeometry.attributes.customColor.array;
  const alphas = particleGeometry.attributes.alpha.array;
  const sizes = particleGeometry.attributes.size.array;

  for(let i=0;i<MAX_PARTICLES;i++){
    const s = particleState[i];
    if(s){
      s.age++;
      // apply physics
      s.vel.add(GRAVITY);
      s.pos.add(s.vel);
      // fade
      const lifeFrac = 1 - (s.age / s.life);
      alphas[i] = Math.max(0, lifeFrac);
      sizes[i] = s.size * (0.6 + lifeFrac*0.9);

      positions[i*3] = s.pos.x;
      positions[i*3+1] = s.pos.y;
      positions[i*3+2] = s.pos.z;

      if(s.age >= s.life || s.pos.y < -10){
        // remove
        particleState[i] = null;
        positions[i*3]=positions[i*3+1]=positions[i*3+2]=9999;
        alphas[i]=0;
      }
    }
  }

  particleGeometry.attributes.position.needsUpdate = true;
  particleGeometry.attributes.alpha.needsUpdate = true;
  particleGeometry.attributes.size.needsUpdate = true;

  // gentle camera motion
  const t = Date.now()*0.0002;
  camera.position.x = Math.sin(t)*6;
  camera.lookAt(0,6,0);

  renderer.render(scene, camera);
}

// responsive
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// helpful: also allow spacebar to launch
window.addEventListener('keydown', (e)=>{ if(e.code==='Space') createFirework(Math.random(), 0.3+Math.random()*0.5); });

</script>
</body>
</html>
